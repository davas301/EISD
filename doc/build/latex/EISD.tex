% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}

\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\floatname{literal-block}{Listing }



\title{EISD Documentation}
\date{April 11, 2016}
\release{0.1}
\author{David Brookes}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{This is documentation for EISD, an IDP ensemble scoring and optimization program from the THG lab at UC Berkeley.}
\label{index:welcome}\label{index:this-is-documentation-for-eisd-an-idp-ensemble-scoring-and-optimization-program-from-the-thg-lab-at-uc-berkeley}
\includegraphics[width=0.300\linewidth]{seal.png}

\includegraphics[width=0.300\linewidth]{biophysics_logo.png}

\includegraphics[width=0.300\linewidth]{header3.png}


\chapter{Table of Contents}
\label{index:table-of-contents}

\section{Getting Started}
\label{intro:getting-started}\label{intro::doc}

\subsection{Introduction}
\label{intro:introduction}
Welcome to EISD! Short for Experimental Inferential Structure
Determination, EISD was developed in Teresa Head-Gordon's lab at
UC Berkeley with the goal of providing probability scores to ensembles of
Intrinsically Disordered Proteins (IDPs) based on their fit to experimental
data and conformational prior distributions. The theory underlying this
code is presented in \phantomsection\label{intro:id1}{\hyperref[references:brhe16]{\emph{{[}BrHe16{]}}}}.

EISD currently allows one to determine probabilities of ensembles using
a number of different experimental data types and priors, as well as to
optimize an ensemble by finding the subset of structures with the highest
probability.


\subsection{Dependencies}
\label{intro:dependencies}
EISD relies on a number of Python libraries and external programs, listed
below:
\begin{itemize}
\item {} 
\textbf{SciPy} \phantomsection\label{intro:id2}{\hyperref[references:joop01]{\emph{{[}JoOP01{]}}}}

\item {} 
\textbf{Biopython} \phantomsection\label{intro:id3}{\hyperref[references:cacc09]{\emph{{[}CACC09{]}}}}

\item {} 
\textbf{SHIFTX2} \phantomsection\label{intro:id4}{\hyperref[references:blgw11]{\emph{{[}BLGW11{]}}}}

\end{itemize}


\subsection{Installation}
\label{intro:installation}
To install EISD, one must first install the dependencies above. This is most
easily done with the \code{pip} tool, which can be installed by following the
instructions \href{https://pip.pypa.io/en/stable/installing/}{here}. Then type on the command line:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} pip install numpy
\PYGZdl{} pip install sklearn
\PYGZdl{} pip install biopython
\end{Verbatim}

Next, clone the git repository:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} git clone https://github.com/davas301/EISD.git
\end{Verbatim}

Now navigate to the downloaded directory and run the setup tool:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} cd eisd/
\PYGZdl{} python setup.py
\end{Verbatim}

The EISD modules can now be imported into any local python program.

Users may also want to install \textbf{SHIFTX2} for chemical shift prediction, whose download and installation
instructions can be found on their website


\section{Use}
\label{use:use}\label{use::doc}\label{use:their-website}

\subsection{Calculating EISD probabilities}
\label{use:calculating-eisd-probabilities}
The most basic use of EISD is to determine a probability score based on
an ensemble of structure's fit to experimental data and some prior distribution on
conformations. This requires back-calculating experimental observables from the ensemble's structure
and determining the probability of the error between these values and the
true experimental value. This procedure is currently implemented for J-coupling
constants and chemical shifts. Prior probabilities are then calculated separately. EISD
only currently implements a uniform prior distribution. See \phantomsection\label{use:id1}{\hyperref[references:brhe16]{\emph{{[}BrHe16{]}}}} for more
details on these procedures.

Below is a tutorial on how to calculate these probabilities using EISD.
This tutorial assumes that SHIFTX2 has been run on every structure in the ensemble
and the output files are saved with the ''.cs'' extension

We begin by building the structures in the ensemble using {\hyperref[modules:structure.Structure]{\emph{\code{structure.Structure}}}}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{from} \PYG{n+nn}{eisd.structure} \PYG{k+kn}{import} \PYG{n}{Structure}

\PYG{n}{pdbdir} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdl{}PATH\PYGZus{}TO\PYGZus{}ENSEMBLE\PYGZus{}DIR\PYGZdl{}/}\PYG{l+s}{\PYGZdq{}}  \PYG{c}{\PYGZsh{} path to directory of PDB files}

\PYG{n}{all\PYGZus{}pdb\PYGZus{}paths} \PYG{o}{=} \PYG{p}{[}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{pdbdir}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)} \PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n}{os}\PYG{o}{.}\PYG{n}{listdir}\PYG{p}{(}\PYG{n}{pdbdir}\PYG{p}{)} \PYG{k}{if}
                 \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.pdb}\PYG{l+s}{\PYGZdq{}} \PYG{o+ow}{in} \PYG{n}{f} \PYG{o+ow}{and} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.cs}\PYG{l+s}{\PYGZdq{}} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{f}\PYG{p}{]}

\PYG{n}{structs} \PYG{o}{=} \PYG{p}{[}\PYG{n}{Structure}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{shiftxfile}\PYG{o}{=}\PYG{n}{f} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.cs}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n}{all\PYGZus{}pdb\PYGZus{}paths}\PYG{p}{]}
\end{Verbatim}

Next we load in experimental data. The methods below (found in {\hyperref[modules:module-readutil]{\emph{\code{readutil}}}})
are specific to the data files in the \code{test} directory but can adapted
for any experimental data format, as long as it returns a dictionary with
{\hyperref[modules:readutil.BaseDataID]{\emph{\code{readutil.BaseDataID}}}} objects as keys and \code{(observable, error)}
tuples as values:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{readutil}

\PYG{n}{jcoup\PYGZus{}data} \PYG{o}{=} \PYG{n}{readutil}\PYG{o}{.}\PYG{n}{get\PYGZus{}ab42\PYGZus{}jcoup\PYGZus{}data}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{shift\PYGZus{}data} \PYG{o}{=} \PYG{n}{readutil}\PYG{o}{.}\PYG{n}{get\PYGZus{}ab42\PYGZus{}shift\PYGZus{}data}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

Next we build our {\hyperref[modules:backcalc.BaseBackCalculator]{\emph{\code{backcalc.BaseBackCalculator}}}} objects that will
be used to approximately calculate experimental observables from structures information:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{eisd.backcalc} \PYG{k+kn}{import} \PYG{n}{JCoupBackCalc}\PYG{p}{,} \PYG{n}{ShiftBackCalc}

\PYG{n}{jcoup\PYGZus{}back\PYGZus{}calc} \PYG{o}{=} \PYG{n}{JCoupBackCalc}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{shift\PYGZus{}back\PYGZus{}calc} \PYG{o}{=} \PYG{n}{ShiftBackCalc}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

And now we use the above to build \code{DataEISD} objects that will calculate
probabilities:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{eisd.eisd} \PYG{k+kn}{import} \PYG{n}{DataEISD}

\PYG{n}{shift\PYGZus{}eisd} \PYG{o}{=} \PYG{n}{DataEISD}\PYG{p}{(}\PYG{n}{shift\PYGZus{}back\PYGZus{}calc}\PYG{p}{,} \PYG{n}{shift\PYGZus{}data}\PYG{p}{)}

\PYG{c}{\PYGZsh{} don\PYGZsq{}t consider back\PYGZhy{}calc error for j\PYGZhy{}coupling (error is all in nuisance parameter variability):}
\PYG{n}{jcoup\PYGZus{}eisd} \PYG{o}{=} \PYG{n}{DataEISD}\PYG{p}{(}\PYG{n}{jcoup\PYGZus{}back\PYGZus{}calc}\PYG{p}{,} \PYG{n}{jcoup\PYGZus{}data}\PYG{p}{,} \PYG{n}{no\PYGZus{}bc\PYGZus{}err}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\end{Verbatim}

Now build a {\hyperref[modules:priors.UniformPrior]{\emph{\code{priors.UniformPrior}}}} object assuming there are
10 ensembles in our hypothesis space (so the prior probability of each is 0.1):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{eisd.priors} \PYG{k+kn}{import} \PYG{n}{UniformPrior}

\PYG{n}{prior} \PYG{o}{=} \PYG{n}{UniformPrior}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\end{Verbatim}

Now we calculate and print the probability of the ensemble given the
experimental data and prior distribution:

\begin{Verbatim}[commandchars=\\\{\}]
shift\PYGZus{}logp = shift\PYGZus{}eisd.calc\PYGZus{}logp(structs)
jcoup\PYGZus{}logp = jcoup\PYGZus{}eisd.calc\PYGZus{}logp(structs)
prior\PYGZus{}logp = prior.calc\PYGZus{}prior\PYGZus{}logp()
total\PYGZus{}logp = shift\PYGZus{}logp + jcoup\PYGZus{}logp + prior\PYGZus{}logp()

outstr = \PYGZdq{}The ensemble at \PYGZpc{}s fits chemical shift data with log probability of \PYGZpc{}.3f, \PYGZdq{} \PYGZbs{}
         \PYGZdq{}J coupling data with log probability of \PYGZpc{}.3f and a conformational prior\PYGZdq{} \PYGZbs{}
          \PYGZdq{}distribution with log probability \PYGZpc{}.3f\PYGZdq{} The total log probability is then \PYGZpc{}.3f\PYGZdq{} \PYGZbs{}
          \PYGZpc{} (pdbdir, shift\PYGZus{}logp, jcoup\PYGZus{}logp, prior\PYGZus{}logp, total\PYGZus{}logp)
print outstr
\end{Verbatim}


\subsection{Finding optimal subsets}
\label{use:finding-optimal-subsets}
Due to EISD's size extensivity, it is ideal for finding the optimal subset of
an ensemble that maximizes the probabilities found above. This optimization
is implemented in the using a simulated annealing to swap out structures in the subset
with structures from the full ensemble.

Below is an example showing how to perform this optimization with J-coupling
and chemical shift experimental data and a Uniform Prior. Again, this assumes
that SHIFTX2 has been run for every structure in the full ensemble.

First define the directory where the full ensemble of structures is stored.
This is referred to as the ``reservoir'' of structures. Also define the size
of the subset that will be optimized and the number of iterations of
simulated annealing to be performed. Additionally provide the path to a  file that will
contain the names of the pdb files that make up the optimal ensemble, as well
as a file for storing optimization statistics:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{pdbdir} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdl{}PATH\PYGZus{}TO\PYGZus{}ENSEMBLE\PYGZus{}DIR\PYGZdl{}/}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{subset\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{1000}
\PYG{n}{niter} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{l+m+mf}{1e6}\PYG{p}{)}

\PYG{n}{savefile} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{../output/\PYGZdl{}OPT\PYGZus{}FILE\PYGZdl{}}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{stats\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{../output/\PYGZdl{}STATS\PYGZus{}FILE\PYGZdl{}}\PYG{l+s}{\PYGZdq{}}
\end{Verbatim}

Now build a {\hyperref[modules:priors.BasePrior]{\emph{\code{priors.BasePrior}}}} object and {\hyperref[modules:eisd.DataEISD]{\emph{\code{eisd.DataEISD}}}} objects
for each set of experimental data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{eisd.priors} \PYG{k+kn}{import} \PYG{n}{UniformPrior}
\PYG{k+kn}{from} \PYG{n+nn}{eisd.eisd} \PYG{k+kn}{import} \PYG{n}{DataEISD}
\PYG{k+kn}{from} \PYG{n+nn}{backcalc} \PYG{k+kn}{import} \PYG{n}{JCoupBackCalc}\PYG{p}{,} \PYG{n}{ShiftBackCalc}
\PYG{k+kn}{import} \PYG{n+nn}{eisd.readutil}

\PYG{n}{prior} \PYG{o}{=} \PYG{n}{UniformPrior}\PYG{p}{(}\PYG{n}{niter}\PYG{p}{)}  \PYG{c}{\PYGZsh{} assume every iterations produces a new hypothesis ensemble}

\PYG{n}{jcoup\PYGZus{}eisd} \PYG{o}{=} \PYG{n}{DataEISD}\PYG{p}{(}\PYG{n}{JCoupBackCalc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{eisd}\PYG{o}{.}\PYG{n}{readutil}\PYG{o}{.}\PYG{n}{get\PYGZus{}ab42\PYGZus{}jcoup\PYGZus{}data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                      \PYG{n}{no\PYGZus{}bc\PYGZus{}err}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{n}{shift\PYGZus{}eisd} \PYG{o}{=} \PYG{n}{DataEISD}\PYG{p}{(}\PYG{n}{ShiftBackCalc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{eisd}\PYG{o}{.}\PYG{n}{readutil}\PYG{o}{.}\PYG{n}{get\PYGZus{}ab42\PYGZus{}shift\PYGZus{}data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} put eisd\PYGZsq{}s together in a list:}
\PYG{n}{data\PYGZus{}eisds} \PYG{o}{=} \PYG{p}{[}\PYG{n}{jcoup\PYGZus{}eisd}\PYG{p}{,} \PYG{n}{shift\PYGZus{}eisd}\PYG{p}{]}
\end{Verbatim}

Now define a cooling schedule for simulated annealing. Below is the default
schedule:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cool\PYGZus{}sched}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Cooling schedule}

\PYG{l+s+sd}{    :param t: fraction of iterations}
\PYG{l+s+sd}{    :return: \PYGZdq{}Temperature\PYGZdq{} for simulated annealing}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{t}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}
\end{Verbatim}

Now we can build the {\hyperref[modules:eisd.EISDOPT]{\emph{\code{eisd.EISDOPT}}}} object and begin the optimization:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{eisd.eisd} \PYG{k+kn}{import} \PYG{n}{EISDOPT}

\PYG{n}{optimizer} \PYG{o}{=} \PYG{n}{EISDOPT}\PYG{p}{(}\PYG{n}{pdbdir}\PYG{p}{,} \PYG{n}{prior}\PYG{p}{,} \PYG{n}{data\PYGZus{}eisds}\PYG{p}{,} \PYG{n}{savefile}\PYG{p}{,}
                    \PYG{n}{subsize}\PYG{o}{=}\PYG{n}{subset\PYGZus{}size}\PYG{p}{,} \PYG{n}{verbose}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,}
                    \PYG{n}{stats\PYGZus{}file}\PYG{o}{=}\PYG{n}{stats\PYGZus{}file}\PYG{p}{)}

\PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{opt}\PYG{p}{(}\PYG{n}{niter}\PYG{p}{,} \PYG{n}{cool\PYGZus{}sched}\PYG{o}{=}\PYG{n}{cool\PYGZus{}sched}\PYG{p}{)}
\end{Verbatim}


\section{Modules}
\label{modules:modules}\label{modules::doc}

\subsection{eisd}
\label{modules:eisd}\label{modules:module-eisd}\index{eisd (module)}\index{DataEISD (class in eisd)}

\begin{fulllineitems}
\phantomsection\label{modules:eisd.DataEISD}\pysiglinewithargsret{\strong{class }\code{eisd.}\bfcode{DataEISD}}{\emph{back\_calc}, \emph{exp\_data}, \emph{no\_exp\_err=False}, \emph{no\_params=False}, \emph{no\_bc\_err=False}, \emph{no\_opt=False}}{}
Implementation of the Experimental Inferential Structure Determination
model. This does not include prior probabilities (priors should be
calculated separately). Each DataEISD object calculates probabilities
for one data type
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{back\_calc}} -- BaseBackCalculator object

\item {} 
\textbf{\texttt{exp\_data}} -- experimental data corresponding to back-calc

\item {} 
\textbf{\texttt{no\_exp\_err}} -- True if experimental error should not contribute

\item {} 
\textbf{\texttt{no\_params}} -- True if parameter probabilities should not contribute

\item {} 
\textbf{\texttt{no\_bc\_err}} -- True if back-calculation error should not contribute

\item {} 
\textbf{\texttt{no\_opt}} -- True if no optimization should be performed--just calculate error probability from normal

\end{itemize}

\end{description}\end{quote}
\index{\_eval() (eisd.DataEISD method)}

\begin{fulllineitems}
\phantomsection\label{modules:eisd.DataEISD._eval}\pysiglinewithargsret{\bfcode{\_eval}}{\emph{structs}, \emph{params}, \emph{bc\_err}, \emph{j}}{}
Given a list of structures,  bc\_err, params and a data point index,
return the experimental error at the data point. This essentially
implements equation 5 in Brookes (2016).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{structs}} -- list of Structure objects

\item {} 
\textbf{\texttt{params}} -- back-calc parameters

\item {} 
\textbf{\texttt{bc\_err}} -- back-calculation error

\item {} 
\textbf{\texttt{j}} -- index of data point

\end{itemize}

\item[{Returns}] \leavevmode
experimental error

\end{description}\end{quote}

\end{fulllineitems}

\index{\_logp\_bc\_err() (eisd.DataEISD method)}

\begin{fulllineitems}
\phantomsection\label{modules:eisd.DataEISD._logp_bc_err}\pysiglinewithargsret{\bfcode{\_logp\_bc\_err}}{\emph{value}, \emph{j}}{}
Log probability of back-calculation error
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{value}} -- value of error

\item {} 
\textbf{\texttt{j}} -- index of data point

\end{itemize}

\item[{Returns}] \leavevmode
log probability

\end{description}\end{quote}

\end{fulllineitems}

\index{\_logp\_exp\_err() (eisd.DataEISD method)}

\begin{fulllineitems}
\phantomsection\label{modules:eisd.DataEISD._logp_exp_err}\pysiglinewithargsret{\bfcode{\_logp\_exp\_err}}{\emph{value}, \emph{j}}{}
Log probability of experimental error
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{value}} -- error value

\item {} 
\textbf{\texttt{j}} -- index of experimental data point

\end{itemize}

\item[{Returns}] \leavevmode
log probability

\end{description}\end{quote}

\end{fulllineitems}

\index{\_logp\_params() (eisd.DataEISD method)}

\begin{fulllineitems}
\phantomsection\label{modules:eisd.DataEISD._logp_params}\pysiglinewithargsret{\bfcode{\_logp\_params}}{\emph{value}}{}
Calculate the log probability of back-calculator parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{value}} -- back-calculator parameters

\item[{Returns}] \leavevmode
log probability of parameters

\end{description}\end{quote}

\end{fulllineitems}

\index{\_logp\_total\_err() (eisd.DataEISD method)}

\begin{fulllineitems}
\phantomsection\label{modules:eisd.DataEISD._logp_total_err}\pysiglinewithargsret{\bfcode{\_logp\_total\_err}}{\emph{value}, \emph{j}}{}
For the no-opt sceneario. Return log probability of an error
at data point j assuming the error distribution is a normal with
variance equal to the sum of the experimental and back-calculator
error variances
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{value}} -- value of error

\item {} 
\textbf{\texttt{j}} -- index of data point

\end{itemize}

\item[{Returns}] \leavevmode
log probability

\end{description}\end{quote}

\end{fulllineitems}

\index{\_random\_bc\_err() (eisd.DataEISD method)}

\begin{fulllineitems}
\phantomsection\label{modules:eisd.DataEISD._random_bc_err}\pysiglinewithargsret{\bfcode{\_random\_bc\_err}}{\emph{j}}{}
Return a random back-calculator error
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{j}} -- index of data point

\item[{Returns}] \leavevmode
random error

\end{description}\end{quote}

\end{fulllineitems}

\index{\_random\_exp\_err() (eisd.DataEISD method)}

\begin{fulllineitems}
\phantomsection\label{modules:eisd.DataEISD._random_exp_err}\pysiglinewithargsret{\bfcode{\_random\_exp\_err}}{\emph{j}}{}
Return a random experimental error
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{j}} -- index of experimental data point

\item[{Returns}] \leavevmode
random error

\end{description}\end{quote}

\end{fulllineitems}

\index{\_random\_params() (eisd.DataEISD method)}

\begin{fulllineitems}
\phantomsection\label{modules:eisd.DataEISD._random_params}\pysiglinewithargsret{\bfcode{\_random\_params}}{}{}
See BaseBackCalculator for more info
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
random parameter set

\end{description}\end{quote}

\end{fulllineitems}

\index{calc\_logp() (eisd.DataEISD method)}

\begin{fulllineitems}
\phantomsection\label{modules:eisd.DataEISD.calc_logp}\pysiglinewithargsret{\bfcode{calc\_logp}}{\emph{structs}}{}
Calculate the full EISD log probability given an ensemble
:param structs: list of Structure objects
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
log probability

\end{description}\end{quote}

\end{fulllineitems}

\index{compute\_all\_back\_calc() (eisd.DataEISD method)}

\begin{fulllineitems}
\phantomsection\label{modules:eisd.DataEISD.compute_all_back_calc}\pysiglinewithargsret{\bfcode{compute\_all\_back\_calc}}{\emph{structs}, \emph{bc\_params}, \emph{j}}{}
Perform back-calculation on every input structure for data point j
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{structs}} -- list of Structure objects

\item {} 
\textbf{\texttt{bc\_params}} -- input parameters for back-calculator

\item {} 
\textbf{\texttt{j}} -- index of data point to back-calculate for

\end{itemize}

\item[{Returns}] \leavevmode
vector of back-calculations

\end{description}\end{quote}

\end{fulllineitems}

\index{compute\_back\_calc\_mean() (eisd.DataEISD method)}

\begin{fulllineitems}
\phantomsection\label{modules:eisd.DataEISD.compute_back_calc_mean}\pysiglinewithargsret{\bfcode{compute\_back\_calc\_mean}}{\emph{structs}, \emph{bc\_params}, \emph{j}}{}
Compute mean of back-calculation on input structures for data point j
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{structs}} -- list of Structure objects

\item {} 
\textbf{\texttt{bc\_params}} -- input parameters for back-calculator

\item {} 
\textbf{\texttt{j}} -- index of data point to back-calculate for

\end{itemize}

\item[{Returns}] \leavevmode
mean of back-calculations

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{EISDOPT (class in eisd)}

\begin{fulllineitems}
\phantomsection\label{modules:eisd.EISDOPT}\pysiglinewithargsret{\strong{class }\code{eisd.}\bfcode{EISDOPT}}{\emph{pdb\_dir}, \emph{prior}, \emph{data\_eisds}, \emph{savefile}, \emph{subsize=1000}, \emph{verbose=True}, \emph{stats\_file=None}}{}
Class for optimizing an ensemble based on EISD probabilities
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pdb\_dir}} -- path to full ensemble of pdb structures

\item {} 
\textbf{\texttt{prior}} -- a BasePrior object

\item {} 
\textbf{\texttt{data\_eisds}} -- list of DataEISD objects

\item {} 
\textbf{\texttt{savefile}} -- file to save best ensemble to (list of pdb names)

\item {} 
\textbf{\texttt{subsize}} -- size of sub-ensemble to optimize

\item {} 
\textbf{\texttt{verbose}} -- if True, will print updates

\item {} 
\textbf{\texttt{stats\_file}} -- file to save statistics to (optional)

\end{itemize}

\end{description}\end{quote}
\index{\_build\_start\_set() (eisd.EISDOPT method)}

\begin{fulllineitems}
\phantomsection\label{modules:eisd.EISDOPT._build_start_set}\pysiglinewithargsret{\bfcode{\_build\_start\_set}}{}{}
Build a random start set of structures
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
list of files and list of Structure objects

\end{description}\end{quote}

\end{fulllineitems}

\index{\_calc\_data\_prob() (eisd.EISDOPT method)}

\begin{fulllineitems}
\phantomsection\label{modules:eisd.EISDOPT._calc_data_prob}\pysiglinewithargsret{\bfcode{\_calc\_data\_prob}}{}{}
Calculate the probability of the data for the current set of structures
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
probability of data

\end{description}\end{quote}

\end{fulllineitems}

\index{\_perturb() (eisd.EISDOPT method)}

\begin{fulllineitems}
\phantomsection\label{modules:eisd.EISDOPT._perturb}\pysiglinewithargsret{\bfcode{\_perturb}}{}{}
Randomly remove a structure and add a random structure from the
reservoir

\end{fulllineitems}

\index{\_restore() (eisd.EISDOPT method)}

\begin{fulllineitems}
\phantomsection\label{modules:eisd.EISDOPT._restore}\pysiglinewithargsret{\bfcode{\_restore}}{}{}
Restore the system to its state before the last perturbation

\end{fulllineitems}

\index{default\_cool() (eisd.EISDOPT static method)}

\begin{fulllineitems}
\phantomsection\label{modules:eisd.EISDOPT.default_cool}\pysiglinewithargsret{\strong{static }\bfcode{default\_cool}}{\emph{t}}{}
Default cooling schedule for simulated annealing
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{t}} -- fraction of iterations

\item[{Returns}] \leavevmode
``Temperature'' for simulated annealing

\end{description}\end{quote}

\end{fulllineitems}

\index{opt() (eisd.EISDOPT method)}

\begin{fulllineitems}
\phantomsection\label{modules:eisd.EISDOPT.opt}\pysiglinewithargsret{\bfcode{opt}}{\emph{niter}, \emph{cool\_sched=None}}{}
Perform simulated annealing procedure to find the subset of structures
that maximimizes probability. Requires the number of iterations and
the cooling schedule, which is a callable function that takes the
current fraction of iterations performed
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{niter}} -- number of iterations

\item {} 
\textbf{\texttt{cool\_sched}} -- callable cooling schedule function

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{backcalc}
\label{modules:module-backcalc}\label{modules:backcalc}\index{backcalc (module)}\index{BaseBackCalculator (class in backcalc)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.BaseBackCalculator}\pysiglinewithargsret{\strong{class }\code{backcalc.}\bfcode{BaseBackCalculator}}{\emph{nparams}}{}
Abstract base class for back calculators
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{nparams}} -- number of nuisance parameters

\end{description}\end{quote}
\index{back\_calc() (backcalc.BaseBackCalculator method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.BaseBackCalculator.back_calc}\pysiglinewithargsret{\bfcode{back\_calc}}{\emph{xi}, \emph{params}}{}
Perform the back-calculation given a structural measurement and
necessary parameters.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{xi}} -- a Measurement returned by self.get\_struct\_data()

\item {} 
\textbf{\texttt{params}} -- list of nuisance parameter values for this back-calc

\end{itemize}

\item[{Returns}] \leavevmode
a Measurement object containing the back-calculated value

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_default\_err() (backcalc.BaseBackCalculator method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.BaseBackCalculator.get_default_err}\pysiglinewithargsret{\bfcode{get\_default\_err}}{\emph{data\_id}}{}
Get the default (i.e. most probable) error for this back-calculator
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{data\_id}} -- a DataID object

\item[{Returns}] \leavevmode
the default error corresponding to the input data id

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_default\_params() (backcalc.BaseBackCalculator method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.BaseBackCalculator.get_default_params}\pysiglinewithargsret{\bfcode{get\_default\_params}}{}{}
Get the default parameters for this back-calculator
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
List of default values (one for each param)

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_default\_struct\_val() (backcalc.BaseBackCalculator method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.BaseBackCalculator.get_default_struct_val}\pysiglinewithargsret{\bfcode{get\_default\_struct\_val}}{}{}
Returns a default structural value for the relevant
structural information needed by this back-calculator.
Used to initialize models
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
default Measurement object

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_err\_sig() (backcalc.BaseBackCalculator method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.BaseBackCalculator.get_err_sig}\pysiglinewithargsret{\bfcode{get\_err\_sig}}{\emph{data\_id}}{}
Get error standard deviation for a data point
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{data\_id}} -- DataID object for the data point

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_random\_err() (backcalc.BaseBackCalculator method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.BaseBackCalculator.get_random_err}\pysiglinewithargsret{\bfcode{get\_random\_err}}{\emph{data\_id}}{}
Get a value drawn from the error distribution of this back-calculator
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{data\_id}} -- a DataID object

\item[{Returns}] \leavevmode
a random error taken from the distribution corresponding to the input data id

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_random\_params() (backcalc.BaseBackCalculator method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.BaseBackCalculator.get_random_params}\pysiglinewithargsret{\bfcode{get\_random\_params}}{}{}
Get values drawn randomly  from the distributions of this
back-calculator's parameters
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
List of random values (one for each param)

\end{description}\end{quote}

\end{fulllineitems}

\index{logp\_err() (backcalc.BaseBackCalculator method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.BaseBackCalculator.logp_err}\pysiglinewithargsret{\bfcode{logp\_err}}{\emph{err}, \emph{data\_id}}{}
Return the log probability of an error
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{err}} -- the error value

\item {} 
\textbf{\texttt{data\_id}} -- the DataID corresponding to the input error

\end{itemize}

\item[{Returns}] \leavevmode
the log probability of the input error

\end{description}\end{quote}

\end{fulllineitems}

\index{logp\_params() (backcalc.BaseBackCalculator method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.BaseBackCalculator.logp_params}\pysiglinewithargsret{\bfcode{logp\_params}}{\emph{params}}{}
Return the log probability of a set of parameter values
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{params}} -- list of input parameters for this back-calculator

\item[{Returns}] \leavevmode
log probability of the input parameters

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{JCoupBackCalc (class in backcalc)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.JCoupBackCalc}\pysiglinewithargsret{\strong{class }\code{backcalc.}\bfcode{JCoupBackCalc}}{\emph{err\_mu=0}, \emph{err\_sig=0.73}, \emph{mu\_a=6.51}, \emph{mu\_b=-1.76}, \emph{mu\_c=1.6}, \emph{sig\_a=0.37416573867739417}, \emph{sig\_b=0.17320508075688773}, \emph{sig\_c=0.28284271247461901}}{}
Back calculator for J-coupling constants from dihedral angles
Calculation is done with the Karplus equation: \$\$ J(phi) = Acos\textasciicircum{}2(phi) + Bcos(phi) + C \$\$
Constructor requires parameters for the Gaussian random variables
that will represent the coefficients in the Karplus equation
and a dictionary containing the errors mean and standard deviations
for every type of structural measurement. Default Karplus coeff means,
stdevs and and error stdev are the values based on those in:
\begin{quote}

Vuister and Bax, ``Quantatative J Correlation: a new approach for meausuring homonuclear
three bond J coupling constants in N15 eriched proteins'' \emph{J.Am.Chem.Soc}, \textbf{1993},
\emph{115} (17). pp 7772:7777
\end{quote}
\index{back\_calc() (backcalc.JCoupBackCalc method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.JCoupBackCalc.back_calc}\pysiglinewithargsret{\bfcode{back\_calc}}{\emph{xi}, \emph{back\_params}}{}
Implemenation of the Karplus equation. See BaseBackCalculator for more
info
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{xi}} -- 

\item {} 
\textbf{\texttt{back\_params}} -- 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_default\_err() (backcalc.JCoupBackCalc method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.JCoupBackCalc.get_default_err}\pysiglinewithargsret{\bfcode{get\_default\_err}}{\emph{data\_id=None}}{}
Default if mean of error distribution See BaseBackCalculator for more
info
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{data\_id}} -- 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_default\_params() (backcalc.JCoupBackCalc method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.JCoupBackCalc.get_default_params}\pysiglinewithargsret{\bfcode{get\_default\_params}}{}{}
Return mean of param values. See BaseBackCalculator for more info
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_default\_struct\_val() (backcalc.JCoupBackCalc method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.JCoupBackCalc.get_default_struct_val}\pysiglinewithargsret{\bfcode{get\_default\_struct\_val}}{}{}
Default is {[}pi, pi{]} dihedral angle. See BaseBackCalculator for more info
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_err\_sig() (backcalc.JCoupBackCalc method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.JCoupBackCalc.get_err_sig}\pysiglinewithargsret{\bfcode{get\_err\_sig}}{\emph{data\_id=None}}{}
See BaseBackCalculator for more info
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{data\_id}} -- 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_random\_err() (backcalc.JCoupBackCalc method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.JCoupBackCalc.get_random_err}\pysiglinewithargsret{\bfcode{get\_random\_err}}{\emph{data\_id=None}}{}
data\_id is optional for this back-calculator. See BaseBackCalculator for
more info
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{data\_id}} -- 

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_random\_params() (backcalc.JCoupBackCalc method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.JCoupBackCalc.get_random_params}\pysiglinewithargsret{\bfcode{get\_random\_params}}{}{}
See BaseBackCalculator for more info
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{logp\_err() (backcalc.JCoupBackCalc method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.JCoupBackCalc.logp_err}\pysiglinewithargsret{\bfcode{logp\_err}}{\emph{err}, \emph{data\_id=None}}{}
Error is represemted as a normal. See BaseBackCalculator for more info
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{err}} -- 

\item {} 
\textbf{\texttt{data\_id}} -- 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{logp\_params() (backcalc.JCoupBackCalc method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.JCoupBackCalc.logp_params}\pysiglinewithargsret{\bfcode{logp\_params}}{\emph{params}}{}
Parameters are represented as normals. See BaseBackCalculator for more
info
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{params}} -- 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ShiftBackCalc (class in backcalc)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.ShiftBackCalc}\pysigline{\strong{class }\code{backcalc.}\bfcode{ShiftBackCalc}}
Back calculator for converting pdb files to chemical shifts.
Uses SHIFTX2 for the back-calculation, which has no nuisance
parameters
\index{back\_calc() (backcalc.ShiftBackCalc method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.ShiftBackCalc.back_calc}\pysiglinewithargsret{\bfcode{back\_calc}}{\emph{xi}, \emph{params}}{}
In this case, xi contains the back-calculated measurement.
See BaseBackCalculator for more info.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{xi}} -- 

\item {} 
\textbf{\texttt{params}} -- 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_default\_err() (backcalc.ShiftBackCalc method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.ShiftBackCalc.get_default_err}\pysiglinewithargsret{\bfcode{get\_default\_err}}{\emph{data\_id=None}}{}
Default is 0.0. See BaseBackCalculator for more info
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{data\_id}} -- 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_default\_params() (backcalc.ShiftBackCalc method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.ShiftBackCalc.get_default_params}\pysiglinewithargsret{\bfcode{get\_default\_params}}{}{}
No nuisance parameters required for this model. See BaseBackCalculator
for more info
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_default\_struct\_val() (backcalc.ShiftBackCalc method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.ShiftBackCalc.get_default_struct_val}\pysiglinewithargsret{\bfcode{get\_default\_struct\_val}}{}{}
Return a shift id for the first measurement of the first
structure
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_err\_sig() (backcalc.ShiftBackCalc method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.ShiftBackCalc.get_err_sig}\pysiglinewithargsret{\bfcode{get\_err\_sig}}{\emph{data\_id}}{}
Get the std corresponding to the SHIFTX2 rmsd for this data id
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{data\_id}} -- 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_random\_err() (backcalc.ShiftBackCalc method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.ShiftBackCalc.get_random_err}\pysiglinewithargsret{\bfcode{get\_random\_err}}{\emph{data\_id}}{}
Return a random value from the normal distribution corresponding
to the SHIFTX2 rmsd value for this data id. See BaseBackCalculator
for more info
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{data\_id}} -- 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_random\_params() (backcalc.ShiftBackCalc method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.ShiftBackCalc.get_random_params}\pysiglinewithargsret{\bfcode{get\_random\_params}}{}{}
No nuisance parameters required for this model. See BaseBackCalculator
for more info
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{logp\_err() (backcalc.ShiftBackCalc method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.ShiftBackCalc.logp_err}\pysiglinewithargsret{\bfcode{logp\_err}}{\emph{err}, \emph{data\_id}}{}
Error represented as gaussian with std based on SHIFTX2 reported rmsd
See BaseBackCalculator for more info
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{err}} -- 

\item {} 
\textbf{\texttt{data\_id}} -- 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{logp\_params() (backcalc.ShiftBackCalc method)}

\begin{fulllineitems}
\phantomsection\label{modules:backcalc.ShiftBackCalc.logp_params}\pysiglinewithargsret{\bfcode{logp\_params}}{\emph{params=None}}{}
No nuisance parameters required for this model. See BaseBackCalculator
for more info
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{params}} -- 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{priors}
\label{modules:priors}\label{modules:module-priors}\index{priors (module)}\index{BasePrior (class in priors)}

\begin{fulllineitems}
\phantomsection\label{modules:priors.BasePrior}\pysigline{\strong{class }\code{priors.}\bfcode{BasePrior}}
Abstract base class for prior distributions
\index{calc\_prior\_logp() (priors.BasePrior method)}

\begin{fulllineitems}
\phantomsection\label{modules:priors.BasePrior.calc_prior_logp}\pysiglinewithargsret{\bfcode{calc\_prior\_logp}}{\emph{*args}}{}
Calculate the prior log probability for a list of Structures that make
up an ensemble
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{args}} -- specific arguments

\item[{Returns}] \leavevmode
log probability of ensemble in this prior distribution

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_arg() (priors.BasePrior method)}

\begin{fulllineitems}
\phantomsection\label{modules:priors.BasePrior.get_arg}\pysiglinewithargsret{\bfcode{get\_arg}}{\emph{struct}}{}
Build the arguments required to calculate the prior given a
single structure. So the input to calc\_prior\_logp shoudl be a
list of these args
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{struct}} -- a Structure object

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{UniformPrior (class in priors)}

\begin{fulllineitems}
\phantomsection\label{modules:priors.UniformPrior}\pysiglinewithargsret{\strong{class }\code{priors.}\bfcode{UniformPrior}}{\emph{n}}{}
Uniform prior distribuiton across space of ensembles
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{n}} -- number of candidate ensembles

\end{description}\end{quote}
\index{calc\_prior\_logp() (priors.UniformPrior method)}

\begin{fulllineitems}
\phantomsection\label{modules:priors.UniformPrior.calc_prior_logp}\pysiglinewithargsret{\bfcode{calc\_prior\_logp}}{}{}
Probability is just 1/n. See BasePrior for more info
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_arg() (priors.UniformPrior method)}

\begin{fulllineitems}
\phantomsection\label{modules:priors.UniformPrior.get_arg}\pysiglinewithargsret{\bfcode{get\_arg}}{\emph{struct=None}}{}
No arguments for this prior. See BasePrior for more info
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{struct}} -- a Structure object

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{structure}
\label{modules:module-structure}\label{modules:structure}\index{structure (module)}\index{Structure (class in structure)}

\begin{fulllineitems}
\phantomsection\label{modules:structure.Structure}\pysiglinewithargsret{\strong{class }\code{structure.}\bfcode{Structure}}{\emph{pdbfile}, \emph{shiftxfile=None}, \emph{runshiftx=None}, \emph{energy=None}}{}
Class for representing and modifying protein structures. Interfaces
significantly with MMTK.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pdbfile}} -- path to the pdbfile containing the representation of this structure

\item {} 
\textbf{\texttt{shiftxfile}} -- file containing back-calculated SHIFTX2 data for this structure

\item {} 
\textbf{\texttt{runshiftx}} -- an optional RunShiftX instance

\end{itemize}

\end{description}\end{quote}
\index{\_get\_all\_dihed() (structure.Structure method)}

\begin{fulllineitems}
\phantomsection\label{modules:structure.Structure._get_all_dihed}\pysiglinewithargsret{\bfcode{\_get\_all\_dihed}}{}{}
Retrieve all phi, psi dihedral angles in this structure
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a \{res\_num: (phi, psi)\} dict

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_struct\_measure() (structure.Structure method)}

\begin{fulllineitems}
\phantomsection\label{modules:structure.Structure.get_struct_measure}\pysiglinewithargsret{\bfcode{get\_struct\_measure}}{\emph{exp\_id}}{}
Get a structural measurement from a DataID corresponding to an
experimental measurement. This structural measurement can be
input into a back-calculator
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{exp\_id}} -- An experimental data ID (ShiftID or JCoupID)

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{readutil}
\label{modules:readutil}\label{modules:module-readutil}\index{readutil (module)}\index{BaseDataID (class in readutil)}

\begin{fulllineitems}
\phantomsection\label{modules:readutil.BaseDataID}\pysigline{\strong{class }\code{readutil.}\bfcode{BaseDataID}}
Base class for objects that contain unique IDs for data points. The goal
of these classes is to ensure that experimental measurements are
solidly connected to the corresponding structural and back-calculation
measurements. These IDs must be hashable and have equality comparisons

\end{fulllineitems}

\index{JCoupID (class in readutil)}

\begin{fulllineitems}
\phantomsection\label{modules:readutil.JCoupID}\pysiglinewithargsret{\strong{class }\code{readutil.}\bfcode{JCoupID}}{\emph{res\_num}}{}
ID objects for j coupling values. Only requires a residue number
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{res\_num}} -- residue number of measurement

\end{description}\end{quote}

\end{fulllineitems}

\index{Measurement (class in readutil)}

\begin{fulllineitems}
\phantomsection\label{modules:readutil.Measurement}\pysiglinewithargsret{\strong{class }\code{readutil.}\bfcode{Measurement}}{\emph{data\_id=None}, \emph{val=None}}{}
Class for storing all of the info in a data measurement
(experimental or structural). Contains a data ID and a value
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data\_id}} -- a BaseDataID object

\item {} 
\textbf{\texttt{val}} -- value of the measurement

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{RunShiftX (class in readutil)}

\begin{fulllineitems}
\phantomsection\label{modules:readutil.RunShiftX}\pysiglinewithargsret{\strong{class }\code{readutil.}\bfcode{RunShiftX}}{\emph{exe='/usr/local/bin/shiftx2/shiftx2.py'}, \emph{tempdir='./tmp/'}}{}
Class for running the SHIFTX2 command line program
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{exe}} -- path to SHIFTX2 executable

\item {} 
\textbf{\texttt{tempdir}} -- path to a directory to story temporary files

\end{itemize}

\end{description}\end{quote}
\index{\_clean() (readutil.RunShiftX method)}

\begin{fulllineitems}
\phantomsection\label{modules:readutil.RunShiftX._clean}\pysiglinewithargsret{\bfcode{\_clean}}{}{}
Removes temporary files

\end{fulllineitems}

\index{read\_ouput() (readutil.RunShiftX static method)}

\begin{fulllineitems}
\phantomsection\label{modules:readutil.RunShiftX.read_ouput}\pysiglinewithargsret{\strong{static }\bfcode{read\_ouput}}{\emph{f}}{}
Reads a shiftx2 output file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{f}} -- output file to be read

\item[{Returns}] \leavevmode
\{ShiftID: shift\_val\} dict

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_shiftx\_once() (readutil.RunShiftX method)}

\begin{fulllineitems}
\phantomsection\label{modules:readutil.RunShiftX.run_shiftx_once}\pysiglinewithargsret{\bfcode{run\_shiftx\_once}}{\emph{inpath}, \emph{backbone\_only=False}, \emph{clean=True}, \emph{no\_output=True}}{}
Runs SHIFTX2 for a single input pdb file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{inpath}} -- path to input pdb file

\item {} 
\textbf{\texttt{backbone\_only}} -- True if SHIFTX2 should only run for backbone atoms

\item {} 
\textbf{\texttt{clean}} -- True if the temporary files should be deleted

\item {} 
\textbf{\texttt{no\_output}} -- If true, no SHIFTX2 ouput will be shown on

\end{itemize}

\item[{Returns}] \leavevmode
path to output ''.cs'' file

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ShiftID (class in readutil)}

\begin{fulllineitems}
\phantomsection\label{modules:readutil.ShiftID}\pysiglinewithargsret{\strong{class }\code{readutil.}\bfcode{ShiftID}}{\emph{res\_num}, \emph{atom\_name}}{}
Storage objects containing information that identifies a unique chemical
shift. A shift is defined by a residue number and atom name
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{res\_num}} -- residue number of measurement

\item {} 
\textbf{\texttt{atom\_name}} -- name of atom with residue

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_ab42\_jcoup\_data() (in module readutil)}

\begin{fulllineitems}
\phantomsection\label{modules:readutil.get_ab42_jcoup_data}\pysiglinewithargsret{\code{readutil.}\bfcode{get\_ab42\_jcoup\_data}}{}{}
Read the J-coupling data for aB42 in ../test\_data/
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a \{JCoupID: val\} dict

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_ab42\_shift\_data() (in module readutil)}

\begin{fulllineitems}
\phantomsection\label{modules:readutil.get_ab42_shift_data}\pysiglinewithargsret{\code{readutil.}\bfcode{get\_ab42\_shift\_data}}{}{}
Read the shift data for aB42 in ../test\_data/
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a \{ShiftID: val\} dict

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_md\_energies() (in module readutil)}

\begin{fulllineitems}
\phantomsection\label{modules:readutil.get_md_energies}\pysiglinewithargsret{\code{readutil.}\bfcode{get\_md\_energies}}{}{}
Read the energy file containing all the energies for the
MD ensemble in in ../test\_data/
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\{filename: energy\} dict

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_dihed\_file() (in module readutil)}

\begin{fulllineitems}
\phantomsection\label{modules:readutil.read_dihed_file}\pysiglinewithargsret{\code{readutil.}\bfcode{read\_dihed\_file}}{\emph{path}}{}
Read the dihedral angle file written by write\_dihed\_to\_file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- 

\item[{Returns}] \leavevmode
numpy array containg dihedral angles

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_dihed\_to\_file() (in module readutil)}

\begin{fulllineitems}
\phantomsection\label{modules:readutil.write_dihed_to_file}\pysiglinewithargsret{\code{readutil.}\bfcode{write\_dihed\_to\_file}}{\emph{structs}, \emph{outname}, \emph{verbose=True}}{}
Write the dihedral angles of a list of structures into a tab-separated
file where each line represents a single structure and the columns
alternate phi, psi angles for each residue
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{structs}} -- list of Structure objects

\item {} 
\textbf{\texttt{outname}} -- path to where the dihed file should be written

\item {} 
\textbf{\texttt{verbose}} -- If True updates will be written to terminal

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{util}
\label{modules:util}\label{modules:module-util}\index{util (module)}\index{normal\_loglike() (in module util)}

\begin{fulllineitems}
\phantomsection\label{modules:util.normal_loglike}\pysiglinewithargsret{\code{util.}\bfcode{normal\_loglike}}{\emph{x}, \emph{mu}, \emph{sig}}{}
Returns the log likelihood of a value x in a normal distribution with
mean mu and stdev sig.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{x}} -- list of values to calculate probability of

\item {} 
\textbf{\texttt{mu}} -- mean of distribuiton

\item {} 
\textbf{\texttt{sig}} -- standard deviation of distribution

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{References}
\label{references:references}\label{references::doc}\paragraph{References}


\section{License}
\label{license::doc}\label{license:license}
This program is distributed under the BSD license:

\begin{Verbatim}[commandchars=\\\{\}]
Copyright (c) 2016, Teresa Head\PYGZhy{}Gordon and David Brookes
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of UC Berkeley nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \PYGZdq{}AS IS\PYGZdq{} AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Teresa Head\PYGZhy{}Gordon BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
\end{Verbatim}

\begin{thebibliography}{BrHe16}
\bibitem[BrHe16]{BrHe16}{\phantomsection\label{references:brhe16} 
Brookes, David H. and Teresa Head-Gordon. ``Experimental Inferential Structure Determination of Ensembles for Intrinsically Disordered Proteins''. \emph{J. Am. Chem. Soc.}, \textbf{2016}, \emph{138} (13), pp 4530–4538
}
\bibitem[JoOP01]{JoOP01}{\phantomsection\label{references:joop01} 
Jones E, Oliphant E, Peterson P, \emph{et al}. SciPy: Open Source Scientific Tools for Python, 2001-.
}
\bibitem[CACC09]{CACC09}{\phantomsection\label{references:cacc09} 
Peter J.A Cock, et al. ``Biopython: freely available Python tools for computational molecular biology and bioinformatics''. \emph{Bioinformatics}, \textbf{2009}, \emph{25} (11), pp 1422-1423.
}
\bibitem[BLGW11]{BLGW11}{\phantomsection\label{references:blgw11} 
Beomsoo Han, Yifeng Liu, Simon Ginzinger, and David Wishart. ``SHIFTX2: significantly improved protein chemical shift prediction''. \emph{Journal of Biomolecular NMR}, \textbf{2011}, 50 (1), pp 43-57.
}
\end{thebibliography}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{b}
\item {\texttt{backcalc}}, \pageref{modules:module-backcalc}
\indexspace
\bigletter{e}
\item {\texttt{eisd}}, \pageref{modules:module-eisd}
\indexspace
\bigletter{p}
\item {\texttt{priors}}, \pageref{modules:module-priors}
\indexspace
\bigletter{r}
\item {\texttt{readutil}}, \pageref{modules:module-readutil}
\indexspace
\bigletter{s}
\item {\texttt{structure}}, \pageref{modules:module-structure}
\indexspace
\bigletter{u}
\item {\texttt{util}}, \pageref{modules:module-util}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
